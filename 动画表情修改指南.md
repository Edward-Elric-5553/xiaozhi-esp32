# ESP32 动画表情修改完整指南

## 概述

本指南将详细介绍如何在小智ESP32项目中修改和添加动画表情显示，包括准备工作、代码修改和测试验证。

## 1. 系统架构分析

### 1.1 表情系统组成

当前项目的表情系统主要由以下几个部分组成：

- **表情显示类**: `ElectronEmojiDisplay`、`OttoEmojiDisplay` 等
- **GIF资源文件**: 以LVGL格式存储的动画资源
- **表情映射**: 将字符串表情名映射到具体的GIF资源
- **显示控制**: 通过LVGL的GIF组件显示动画

### 1.2 支持的板子类型

目前支持动画表情的板子包括：
- `electron-bot`: 电子机器人
- `otto-robot`: Otto机器人
- `esp-hi`: ESP-HI开发板
- `echoear`: EchoEar开发板

## 2. 准备工作

### 2.1 GIF资源要求

- **格式**: GIF动画文件
- **尺寸**: 建议与屏幕分辨率匹配（如360x360）
- **颜色**: 支持RGB565格式
- **帧率**: 建议10-15fps，避免过高帧率影响性能
- **文件大小**: 建议单个GIF文件不超过100KB

### 2.2 工具准备

#### 图像转换工具
项目提供了专门的图像转换工具：

```bash
# 进入转换工具目录
cd scripts/Image_Converter

# 创建虚拟环境
python -m venv venv

# 激活环境 (Windows)
venv\Scripts\activate

# 安装依赖
pip install -r requirements.txt

# 运行转换工具
python lvgl_tools_gui.py
```

#### 转换步骤
1. 准备GIF文件
2. 使用`lvgl_tools_gui.py`转换为LVGL格式
3. 生成的`.c`文件包含图像数据
4. 生成的`.h`文件包含图像声明

## 3. 代码修改示例

### 3.1 添加新表情资源

假设我们要为`electron-bot`添加一个新的"眨眼"表情：

#### 步骤1: 转换GIF资源
使用转换工具将`blink.gif`转换为LVGL格式，生成：
- `blink.c`: 包含图像数据
- `blink.h`: 包含图像声明

#### 步骤2: 添加资源声明
在`electron_emoji_display.h`中添加声明：

```cpp
// 在现有声明后添加
LV_IMAGE_DECLARE(blink);        // 眨眼表情
```

#### 步骤3: 更新表情映射
在`electron_emoji_display.cc`中更新映射表：

```cpp
const ElectronEmojiDisplay::EmotionMap ElectronEmojiDisplay::emotion_maps_[] = {
    // 现有映射...
    {"neutral", &staticstate},
    {"happy", &happy},
    {"sad", &sad},
    {"angry", &anger},
    {"surprised", &scare},
    {"thinking", &buxue},
    
    // 添加新表情
    {"blink", &blink},
    {"wink", &blink},  // 可以将多个名称映射到同一个GIF
    
    {nullptr, nullptr}  // 结束标记
};
```

#### 步骤4: 添加资源文件
将转换生成的`blink.c`文件添加到项目中：
- 可以放在`boards/electron-bot/`目录下
- 或者创建专门的`resources/`目录

### 3.2 创建新的表情显示类

如果要为新的板子添加表情支持，可以参考以下模板：

#### 头文件 (`my_emoji_display.h`):

```cpp
#pragma once

#include <libs/gif/lv_gif.h>
#include "display/lcd_display.h"

// 表情GIF声明
LV_IMAGE_DECLARE(my_neutral);
LV_IMAGE_DECLARE(my_happy);
LV_IMAGE_DECLARE(my_sad);
// 添加更多表情...

class MyEmojiDisplay : public SpiLcdDisplay {
public:
    MyEmojiDisplay(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_handle_t panel,
                   int width, int height, int offset_x, int offset_y, bool mirror_x,
                   bool mirror_y, bool swap_xy, DisplayFonts fonts);

    virtual ~MyEmojiDisplay() = default;

    virtual void SetEmotion(const char* emotion) override;
    virtual void SetChatMessage(const char* role, const char* content) override;
    virtual void SetIcon(const char* icon) override;

private:
    void SetupGifContainer();
    
    lv_obj_t* emotion_gif_;
    
    struct EmotionMap {
        const char* name;
        const lv_image_dsc_t* gif;
    };
    
    static const EmotionMap emotion_maps_[];
};
```

#### 实现文件 (`my_emoji_display.cc`):

```cpp
#include "my_emoji_display.h"
#include <esp_log.h>
#include <cstring>

#define TAG "MyEmojiDisplay"

// 表情映射表
const MyEmojiDisplay::EmotionMap MyEmojiDisplay::emotion_maps_[] = {
    {"neutral", &my_neutral},
    {"happy", &my_happy},
    {"sad", &my_sad},
    // 添加更多映射...
    {nullptr, nullptr}
};

MyEmojiDisplay::MyEmojiDisplay(esp_lcd_panel_io_handle_t panel_io,
                               esp_lcd_panel_handle_t panel, int width, int height,
                               int offset_x, int offset_y, bool mirror_x, bool mirror_y,
                               bool swap_xy, DisplayFonts fonts)
    : SpiLcdDisplay(panel_io, panel, width, height, offset_x, offset_y, mirror_x, mirror_y, swap_xy, fonts),
      emotion_gif_(nullptr) {
    SetupGifContainer();
}

void MyEmojiDisplay::SetupGifContainer() {
    DisplayLockGuard lock(this);
    
    // 清理现有组件
    if (emotion_label_) {
        lv_obj_del(emotion_label_);
    }
    if (chat_message_label_) {
        lv_obj_del(chat_message_label_);
    }
    if (content_) {
        lv_obj_del(content_);
    }
    
    // 创建容器
    content_ = lv_obj_create(container_);
    lv_obj_set_scrollbar_mode(content_, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_size(content_, LV_HOR_RES, LV_HOR_RES);
    lv_obj_set_style_bg_opa(content_, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(content_, 0, 0);
    lv_obj_center(content_);
    
    // 创建GIF组件
    emotion_gif_ = lv_gif_create(content_);
    lv_obj_set_size(emotion_gif_, LV_HOR_RES, LV_HOR_RES);
    lv_obj_set_style_border_width(emotion_gif_, 0, 0);
    lv_obj_set_style_bg_opa(emotion_gif_, LV_OPA_TRANSP, 0);
    lv_obj_center(emotion_gif_);
    lv_gif_set_src(emotion_gif_, &my_neutral);  // 默认表情
    
    // 创建文本标签
    chat_message_label_ = lv_label_create(content_);
    lv_label_set_text(chat_message_label_, "");
    lv_obj_set_width(chat_message_label_, LV_HOR_RES * 0.9);
    lv_label_set_long_mode(chat_message_label_, LV_LABEL_LONG_SCROLL_CIRCULAR);
    lv_obj_set_style_text_align(chat_message_label_, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_align(chat_message_label_, LV_ALIGN_BOTTOM_MID, 0, 0);
}

void MyEmojiDisplay::SetEmotion(const char* emotion) {
    if (!emotion || !emotion_gif_) {
        return;
    }
    
    DisplayLockGuard lock(this);
    
    // 查找匹配的表情
    for (const auto& map : emotion_maps_) {
        if (map.name && strcmp(map.name, emotion) == 0) {
            lv_gif_set_src(emotion_gif_, map.gif);
            ESP_LOGI(TAG, "设置表情: %s", emotion);
            return;
        }
    }
    
    // 未找到匹配表情，使用默认
    lv_gif_set_src(emotion_gif_, &my_neutral);
    ESP_LOGI(TAG, "未知表情'%s'，使用默认", emotion);
}

void MyEmojiDisplay::SetChatMessage(const char* role, const char* content) {
    DisplayLockGuard lock(this);
    
    if (!chat_message_label_) {
        return;
    }
    
    if (content == nullptr || strlen(content) == 0) {
        lv_obj_add_flag(chat_message_label_, LV_OBJ_FLAG_HIDDEN);
        return;
    }
    
    lv_label_set_text(chat_message_label_, content);
    lv_obj_remove_flag(chat_message_label_, LV_OBJ_FLAG_HIDDEN);
    
    ESP_LOGI(TAG, "设置聊天消息 [%s]: %s", role, content);
}

void MyEmojiDisplay::SetIcon(const char* icon) {
    // 根据需要实现图标显示逻辑
}
```

## 4. 编译配置

### 4.1 添加到CMakeLists.txt

确保新添加的源文件被包含在编译中：

```cmake
# 在boards/${BOARD_TYPE}/目录下的文件会自动被包含
# 如果资源文件在其他位置，需要手动添加
file(GLOB BOARD_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/boards/${BOARD_TYPE}/*.cc
    ${CMAKE_CURRENT_SOURCE_DIR}/boards/${BOARD_TYPE}/*.c
    ${CMAKE_CURRENT_SOURCE_DIR}/boards/${BOARD_TYPE}/resources/*.c  # 如果资源在子目录
)
```

### 4.2 配置LVGL

确保LVGL支持GIF：

```
# 在sdkconfig中确保以下配置
CONFIG_LV_USE_GIF=y
CONFIG_LV_USE_ANIMIMG=y
```

## 5. 测试和验证

### 5.1 编译测试

```bash
# 清理并重新编译
idf.py clean
idf.py build
```

### 5.2 功能测试

#### 通过代码测试：

```cpp
// 在应用代码中测试
display->SetEmotion("happy");    // 测试开心表情
display->SetEmotion("sad");      // 测试悲伤表情
display->SetEmotion("blink");    // 测试新添加的眨眼表情
```

#### 通过WebSocket测试：

```json
{
  "type": "emotion",
  "data": {
    "emotion": "happy"
  }
}
```

### 5.3 性能监控

```cpp
// 监控内存使用
ESP_LOGI(TAG, "Free heap: %d", esp_get_free_heap_size());

// 监控帧率
ESP_LOGI(TAG, "FPS: %d", lv_disp_get_fps(lv_disp_get_default()));
```

## 6. 常见问题和解决方案

### 6.1 内存不足

**问题**: GIF文件过大导致内存不足

**解决方案**:
- 减少GIF文件大小和帧数
- 降低颜色深度
- 使用PSRAM存储大文件

### 6.2 显示异常

**问题**: GIF显示不正常或闪烁

**解决方案**:
- 检查GIF格式是否正确
- 确保LVGL配置正确
- 检查显示锁是否正确使用

### 6.3 编译错误

**问题**: 找不到资源文件或声明

**解决方案**:
- 确保`.c`文件被正确包含在CMakeLists.txt中
- 检查`LV_IMAGE_DECLARE`声明是否正确
- 确保头文件路径正确

## 7. 最佳实践

1. **资源优化**: 使用适当的分辨率和帧率，避免过大的GIF文件
2. **内存管理**: 及时释放不用的资源，使用显示锁保护并发访问
3. **错误处理**: 添加适当的错误检查和日志输出
4. **模块化**: 将表情相关代码组织成独立的模块
5. **测试覆盖**: 确保所有表情都经过测试验证

## 8. 参考资源

- [LVGL官方文档](https://docs.lvgl.io/)
- [ESP-IDF编程指南](https://docs.espressif.com/projects/esp-idf/)
- [项目B站教程](https://www.bilibili.com/video/BV12FQkYeEJ3/)
- [LVGL图像转换工具](https://github.com/lvgl/lvgl/blob/master/scripts/LVGLImage.py)

---

通过以上指南，你应该能够成功地为ESP32项目添加和修改动画表情显示功能。如果遇到问题，建议先检查日志输出，然后参考常见问题部分进行排查。